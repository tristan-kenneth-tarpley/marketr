'use strict';

exports.__esModule = true;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _base = require('../../util/base.js');

var _base2 = _interopRequireDefault(_base);

var _tokenize = require('./tokenize.js');

var _tokenize2 = _interopRequireDefault(_tokenize);

var _token_type = require('../../util/token_type.js');

var _token_type2 = _interopRequireDefault(_token_type);

var _util = require('./util.js');

var _compress = require('../css/compress.js');

var _compress2 = _interopRequireDefault(_compress);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * compress options
 */
var compressOpts = {
  'trim': false, // 去除首尾空白字符
  'removeComment': true, // 移除注释
  'simpleDoctype': true, // 简化doctype
  'simpleCharset': true, // 简化charset
  'tagToLower': true, // 小写标签名
  'removeHtmlXmlns': true, // 移除html的命名空间
  'removeInterTagSpace': false, // 移除标签之间的空格，非安全
  'removeEmptyScript': false, // 移除空的script标签
  'removeEmptyStyle': false, // 移除空的style标签
  'removeOptionalAttrs': true, // 移除可选的属性
  'removeAttrsQuote': true, // 移除属性值的引号
  'removeAttrsOptionalValue': true, // 移除可选属性的值
  'removeHttpProtocol': false, // 移除http协议
  'removeHttpsProtocol': false, // 移除https协议
  'removeOptionalEndEag': true, // 移除可选的结束标签
  'optionalEndTagList': null, // 结束标签列表
  'removeVoidElementSlash': true, // 移除单一标签最后的 /
  'compressStyleValue': true, // 压缩标签的style值
  'compressInlineCss': true, // 压缩内联的CSS
  'compressInlineJs': true, // 压缩内联的JS
  'removeInlineJsCdata': true, //
  'compressJsTpl': true, // 压缩前端模版
  'compressTag': true // 压缩标签
};

var HtmlCompress = function (_Base) {
  (0, _inherits3.default)(HtmlCompress, _Base);

  /**
   * constructor
   */
  function HtmlCompress(text) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, HtmlCompress);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Base.call(this, '', options));

    _this._optText = text;
    _this.tokens = [];
    _this.isXML = false;

    _this.index = 0;
    _this.length = 0;

    _this.jsHandle = null;
    _this.cssHandle = null;
    _this.jsTplHandle = null;

    _this.prev = null;
    _this.next = null;

    _this.options = (0, _extends3.default)({}, compressOpts, _this.options);
    return _this;
  }
  /**
   * init tokens
   */


  HtmlCompress.prototype.initTokens = function initTokens() {
    if (typeof this._optText === 'string') {
      var instance = new _tokenize2.default(this._optText, this.options);
      this.tokens = instance.run();
    } else {
      this.tokens = this._optText;
    }
    this.length = this.tokens.length;
  };
  /**
   * compress common
   */


  HtmlCompress.prototype.compressCommon = function compressCommon(token) {
    // compress comment
    if (token.commentBefore.length && this.options.removeComment) {
      var comments = [];
      var start = token.commentBefore[0].start;
      var prev = null;
      var hasSpace = token.start - token.commentBefore[token.commentBefore.length - 1].end > 0;
      token.commentBefore.forEach(function (item) {
        if (item.value.indexOf('<!--!') === 0) {
          comments.push(item);
        }
        if (prev && !hasSpace) {
          hasSpace = item.start - prev.end > 0;
        }
        prev = item;
      });
      token.commentBefore = comments;
      var prevHasRightSpace = false;
      if (this.prev && this.prev.type === _token_type2.default.HTML_TEXT) {
        prevHasRightSpace = /\s$/.test(this.prev.value);
      }
      token.start = !prevHasRightSpace && hasSpace ? start + 1 : start;
    }

    if (!this.prev) {
      if (token.type === _token_type2.default.HTML_DOCTYPE || token.type === _token_type2.default.XML_START) {
        token.start = 0;
        return token;
      }
    }

    if (this.isXML) {
      token.start = this.prev ? this.prev.end : 0;
      return token;
    }

    // safe tags
    var tagTypes = [_token_type2.default.HTML_TAG_START, _token_type2.default.HTML_TAG_END];
    if (tagTypes.indexOf(token.type) > -1 && (0, _util.isSafeTag)(token.ext.tagLowerCase)) {
      token.start = this.prev ? this.prev.end : 0;
    }

    return token;
  };
  /**
   * compress text
   */


  HtmlCompress.prototype.compressText = function compressText(token) {
    // can not remove extra whitespace in title tag
    if (this.prev && this.prev.type === _token_type2.default.HTML_TAG_START) {
      if (this.prev.ext.tagLowerCase === 'title') {
        var spaces = token.start - this.prev.end;
        if (spaces) {
          token.value = new Array(spaces + 1).join(' ') + token.value;
        }
        token.start = this.prev.end;
        return token;
      }
    }

    var value = token.value;
    // 如果文本中含有//，则不去除换行等，主要是一些异步接口（JS环境）会被识别成HTML环境，如果有JS的//注释就要注意了
    if (value.indexOf('//') > -1) {
      return token;
    }
    value = value.replace(/\s+/g, ' ');
    // remove right space
    if (this.options.removeInterTagSpace) {
      value = value.replace(/\s$/, '');
    }
    token.value = value;
    return token;
  };
  /**
   * compress doctype
   */


  HtmlCompress.prototype.compressDocType = function compressDocType(token) {
    if (this.options.simpleDoctype) {
      token.value = '<!Doctype html>';
    }
    token.start = this.prev ? this.prev.end : 0;
    return token;
  };
  /**
   * compress charset
   */


  HtmlCompress.prototype.compressCharset = function compressCharset(token) {
    var attrs = token.ext.attrs;
    var charset = 0;
    var contentValue = '';
    var flag = attrs.some(function (item) {
      var value = item.value || '';
      if (item.nameLowerCase === 'http-equiv' && value.toLowerCase() === 'content-type') {
        charset++;
      } else if (item.nameLowerCase === 'content' && value.indexOf('charset=') > -1) {
        charset++;
        contentValue = item.value;
      } else {
        return true;
      }
    });
    if (flag) {
      return;
    }
    if (charset !== 2 || !contentValue) {
      return;
    }
    var reg = /charset=([\w\-]+)/i;
    var matches = contentValue.match(reg);
    if (matches && matches[1]) {
      // token.value = `<meta charset=${matches[1]}>`;
      token.ext.attrs = [{
        name: 'charset',
        value: matches[1],
        nameLowerCase: 'charset',
        quote: this.options.removeAttrsQuote ? '' : '"'
      }];
    }
    return token;
  };
  /**
   * compress tag start
   */


  HtmlCompress.prototype.compressTagStart = function compressTagStart(token) {
    var _this2 = this;

    if (this.isXML || !this.options.compressTag) {
      return token;
    }
    var lowerTagName = token.ext.tagLowerCase;
    if (!(0, _util.isTag)(lowerTagName)) {
      return token;
    }
    if (this.options.tagToLower) {
      token.ext.tag = lowerTagName;
    }
    if (lowerTagName === 'meta' && this.options.simpleCharset) {
      var ret = this.compressCharset(token);
      if (ret) {
        return ret;
      }
    }
    var attrs = token.ext.attrs;
    var retAttrs = [];
    var options = this.options;
    attrs.forEach(function (attr) {
      if (attr.type === _token_type2.default.TPL) {
        var tplCompress = _this2.compressTpl(attr);
        if (tplCompress) {
          retAttrs.push(tplCompress);
        }
        return;
      }

      var value = attr.value;
      var name = attr.nameLowerCase;

      // remove tag attribute default value
      if (options.removeOptionalAttrs && (0, _util.isTagAttrDefaultValue)(name, value, lowerTagName)) {
        return;
      }

      // remove xmlns attribute in html tag
      if (options.removeHtmlXmlns && lowerTagName === 'html' && name === 'xmlns') {
        return;
      }

      // tag attribute only has name, remove value
      if (options.removeAttrsOptionalValue && (0, _util.isTagAttrOnlyName)(name)) {
        delete attr.value;
        delete attr.quote;
        retAttrs.push(attr);
        return;
      }

      // remove value quote
      if (options.removeAttrsQuote && (0, _util.isAttrValueNoQuote)(value)) {
        delete attr.quote;
        retAttrs.push(attr);
        return;
      }

      // remove http/https protocol prefix
      if (name === 'href' || name === 'src') {
        if (options.removeHttpProtocol && value.indexOf('http://') === 0) {
          attr.value = value.slice(5);
          retAttrs.push(attr);
          return;
        }
        if (options.removeHttpsProtocol && value.indexOf('https://') === 0) {
          attr.value = value.slice(6);
          retAttrs.push(attr);
          return;
        }
      }

      // class value has extra blank chars
      if (name === 'class' && !_this2.hasTpl(value)) {
        attr.value = value.trim().split(/\s+/).join(' ');
        if (attr.value) {
          retAttrs.push(attr);
        }
        return;
      }

      // compress style value
      if (options.compressStyleValue && name === 'style') {
        value = '*{' + value + '}';
        if (_this2.cssHandle && _this2.cssHandle.compress) {
          var compressValue = _this2.cssHandle.compress(value);
          attr.value = compressValue.slice(2, compressValue.length - 1);
        } else {
          var instance = new _compress2.default(value, _this2.options);
          var _compressValue = instance.run();
          attr.value = _compressValue.slice(2, _compressValue.length - 1);
        }
        retAttrs.push(attr);
        return;
      }

      // remove last ; on event
      if (name.indexOf('on') === 0) {
        value = value.trim();
        if (value[value.length - 1] === ';') {
          attr.value = value.slice(0, value.length - 1);
        }
      }

      retAttrs.push(attr);
    });
    // remove / in void element
    if (this.options.removeVoidElementSlash && token.ext.slash) {
      if ((0, _util.isVoidElement)(lowerTagName)) {
        token.ext.slash = false;
      }
    }
    token.ext.attrs = retAttrs;
    return token;
  };
  /**
   * compress tag end
   */


  HtmlCompress.prototype.compressTagEnd = function compressTagEnd(token) {
    // </div> </div> => </div></div>
    var tagTypes = [_token_type2.default.HTML_TAG_END, _token_type2.default.HTML_TAG_STYLE, _token_type2.default.HTML_TAG_SCRIPT];
    if (this.prev && tagTypes.indexOf(this.prev.type) > -1) {
      token.start = this.prev.end;
    }
    var tagLowerCase = token.ext.tagLowerCase;
    if (this.isXML || !(0, _util.isTag)(tagLowerCase)) {
      return token;
    }

    if (this.options.removeOptionalEndEag) {
      if ((0, _util.isOptionalEndTag)(tagLowerCase, this.options.optionalEndTagList)) {
        return;
      }
    }

    if (this.options.tagToLower) {
      token.ext.tag = tagLowerCase;
    }

    return token;
  };
  /**
   * compress style
   */


  HtmlCompress.prototype.compressStyle = function compressStyle(token) {
    // remove whitespace before token
    token.start = this.prev ? this.prev.end : 0;

    if (!this.options.compressTag) {
      return token;
    }

    var contentToken = token.ext.content;
    var contentValue = contentToken.value.trim();
    if (this.options.removeEmptyStyle && !contentValue) {
      return;
    }

    var handle = this.cssHandle;
    if (this.cssHandle && this.cssHandle.compress) {
      handle = this.cssHandle.compress;
    }
    if (this.options.compressInlineCss && handle) {
      token.ext.content = handle(contentToken, this);
    }

    token.ext.start = this.compressTagStart(token.ext.start);
    token.ext.end = this.compressTagEnd(token.ext.end);
    return token;
  };

  /**
   * compress script
   */


  HtmlCompress.prototype.compressScript = function compressScript(token) {
    // remove whitespace before token
    token.start = this.prev ? this.prev.end : 0;

    if (!this.options.compressTag) {
      return token;
    }

    var _token$ext = token.ext,
        start = _token$ext.start,
        content = _token$ext.content,
        end = _token$ext.end;

    token.ext.start = this.compressTagStart(start);
    token.ext.end = this.compressTagEnd(end);
    if (start.ext.isExternal) {
      return token;
    }

    var contentValue = content.value.trim();
    // remove empty script
    if (this.options.removeEmptyScript && !contentValue) {
      return;
    }

    // compress inline script
    if (this.options.compressInlineJs && start.ext.isScript && !start.ext.isExternal) {
      var hasTpl = this.hasTpl(contentValue);
      var handle = this.jsHandle;
      if (this.jsHandle && this.jsHandle.compress) {
        handle = this.jsHandle.compress;
      }
      if (!hasTpl && handle) {
        token.ext.content = handle(content, this);
      }
    }

    // compress js tpl
    if (start.ext.isTpl && this.options.compressJsTpl && this.jsTplHandle) {
      token.ext.content = this.jsTplHandle(content, this);
    }

    return token;
  };
  /**
   * compress tpl
   */


  HtmlCompress.prototype.compressTpl = function compressTpl(token) {
    var instance = this.getTplInstance();
    return instance.compress(token, this);
  };
  /**
   * compress token
   */


  HtmlCompress.prototype.compressToken = function compressToken(token) {
    if (!this.prev && this.options.trim) {
      token.start = 0;
    }
    token = this.compressCommon(token);
    switch (token.type) {
      case _token_type2.default.HTML_DOCTYPE:
        token = this.compressDocType(token);
        break;
      case _token_type2.default.HTML_TAG_START:
        token = this.compressTagStart(token);
        break;
      case _token_type2.default.HTML_TEXT:
        token = this.compressText(token);
        break;
      case _token_type2.default.HTML_TAG_END:
        token = this.compressTagEnd(token);
        break;
      case _token_type2.default.HTML_TAG_STYLE:
        token = this.compressStyle(token);
        break;
      case _token_type2.default.HTML_TAG_SCRIPT:
        token = this.compressScript(token);
        break;
      case _token_type2.default.TPL:
        token = this.compressTpl(token);
        break;
    }
    return token;
  };
  /**
   * run
   */


  HtmlCompress.prototype.run = function run() {
    var retTokens = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    this.initTokens();

    var firstToken = this.tokens[0];
    if (firstToken && firstToken.type === _token_type2.default.XML_START) {
      this.isXML = true;
      this.options.tagToLower = false;
    }
    var result = [];
    while (this.index < this.length) {
      if (this.index) {
        this.prev = this.tokens[this.index - 1];
      }
      var token = this.tokens[this.index++];
      this.next = this.tokens[this.index];

      token = this.compressToken(token);
      if (token) {
        result.push(token);
      }
    }
    return retTokens ? result : (0, _util.token2Text)(result, {
      js: this.jsHandle && this.jsHandle.stringify,
      css: this.cssHandle && this.cssHandle.stringify
    });
  };

  return HtmlCompress;
}(_base2.default);

exports.default = HtmlCompress;
//# sourceMappingURL=compress.js.map