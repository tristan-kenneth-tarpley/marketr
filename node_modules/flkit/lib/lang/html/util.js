'use strict';

exports.__esModule = true;
exports.isTagFirstChar = isTagFirstChar;
exports.isTagNameChar = isTagNameChar;
exports.parseScriptAttrs = parseScriptAttrs;
exports.parseStyleAttrs = parseStyleAttrs;
exports.attrs2Text = attrs2Text;
exports.token2Text = token2Text;
exports.isTagAttrDefaultValue = isTagAttrDefaultValue;
exports.isTagAttrOnlyName = isTagAttrOnlyName;
exports.isAttrValueNoQuote = isAttrValueNoQuote;
exports.isOptionalEndTag = isOptionalEndTag;
exports.isVoidElement = isVoidElement;
exports.isTag = isTag;
exports.isSafeTag = isSafeTag;

var _token_type = require('../../util/token_type.js');

var _token_type2 = _interopRequireDefault(_token_type);

var _util = require('../../util/util.js');

var _config = require('./config.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * check code is tag name first char
 * @param  {Number}  code [char code]
 * @return {Boolean}      []
 */
function isTagFirstChar(code) {
  // a-z ! ? /
  return code >= 0x61 && code <= 0x7a || code === 0x3f || code === 0x21 || code === 0x2f;
}
/**
 * check code is tag name char
 * @param  {Number}  code [char code]
 * @return {Boolean}      []
 */
function isTagNameChar(code) {
  // a-z 0-9 : -
  return code >= 0x61 && code <= 0x7a || code === 0x3a || code === 0x2d || code >= 0x30 && code <= 0x39;
}
/**
 * parse script token attribute
 * @param  {Object} token []
 * @return {Object}             []
 */
function parseScriptAttrs(token) {
  var jsTplTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  var isScript = false,
      isExternal = false,
      type = '';
  var attrs = token.ext.attrs || [],
      i = 0,
      item = void 0;
  for (; item = attrs[i++];) {
    switch (item.name) {
      case 'src':
        isExternal = true;
        break;
      case 'type':
        type = (item.value || '').toLowerCase();
        break;
    }
  }
  if (!type || type === 'text/javascript') {
    isScript = true;
  }
  token.ext.isScript = isScript;
  token.ext.isExternal = isExternal;
  token.ext.type = type;
  token.ext.isTpl = !isScript && jsTplTypes && jsTplTypes.indexOf(type) > -1;
  return token;
}
/**
 * parse style attr
 * @param  {Object} token []
 * @return {Object}       []
 */
function parseStyleAttrs(token) {
  var isStyle = true,
      attrs = token.attrs || [],
      i = 0,
      item,
      value;
  for (; item = attrs[i++];) {
    if (item.name === 'type') {
      value = (item.value || '').toLowerCase();
      if (value && value !== 'text/css') {
        isStyle = false;
      }
      break;
    }
  }
  token.ext.isStyle = isStyle;
  return token;
}

/**
 * tag attrs to text
 */
function attrs2Text() {
  var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  return attrs.map(function (attr) {
    // is tpl
    if (attr.type === _token_type2.default.TPL) {
      return (attr.spaceBefore ? ' ' : '') + attr.value;
    }
    var quote = attr.quote || '';
    if ('value' in attr && 'name' in attr) {
      return attr.name + '=' + quote + attr.value + quote + ' ';
    }
    if ('value' in attr) {
      return attr.value + ' ';
    }
    return attr.name + ' ';
  }).join('').trim();
}

/**
 * start token to text
 */
var startToken2Text = function startToken2Text(token) {
  var attrText = attrs2Text(token.ext.attrs);
  if (attrText) {
    attrText = ' ' + attrText;
  }
  // slash on single tag
  if (token.ext.slash) {
    attrText += ' /';
  }
  return '<' + token.ext.tag + attrText + '>';
};

/**
 * tokens to text
 */
function token2Text() {
  var tokens = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var stringify = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    css: null,
    js: null
  };

  var prevToken = null;
  var result = [];

  tokens.forEach(function (token) {
    // has space between tokens
    if ((0, _util.hasSpaceBetweenTokens)(prevToken, token)) {
      result.push(' ');
    }
    // has comment
    if (token.commentBefore.length) {
      token.commentBefore.forEach(function (item) {
        result.push(item.value);
      });
    }
    var contentToken = void 0;
    switch (token.type) {
      case _token_type2.default.HTML_TAG_START:
        result.push(startToken2Text(token));
        break;
      case _token_type2.default.HTML_TAG_STYLE:
        var start = startToken2Text(token.ext.start);
        result.push(start);
        contentToken = token.ext.content;
        if (!stringify.css || !contentToken.ext.tokens) {
          result.push(contentToken.value);
        } else {
          result.push(stringify.css(contentToken.ext.tokens));
        }
        result.push(token.ext.end.value);
        break;
      case _token_type2.default.HTML_TAG_SCRIPT:
        var startToken = token.ext.start;
        result.push(startToken2Text(startToken));
        contentToken = token.ext.content;
        if (contentToken.ext.tokens) {
          if (startToken.ext.isScript) {
            result.push(stringify.js(contentToken.ext.tokens));
          } else if (startToken.ext.isTpl) {
            result.push(token2Text(contentToken.ext.tokens));
          }
        } else {
          result.push(contentToken.value);
        }
        result.push(token.ext.end.value);
        break;
      case _token_type2.default.HTML_TAG_END:
        result.push('</' + token.ext.tag + '>');
        break;
      default:
        result.push(token.value);
        break;
    }
    prevToken = token;
  });
  return result.join('');
}

/**
 * is tag attribute default value
 */
function isTagAttrDefaultValue(name, value, tag) {
  var lowerValue = (value || '').toLowerCase();
  for (var key in _config.tagAttrDefaultValue) {
    var attrs = _config.tagAttrDefaultValue[key];
    if (key === '*' || key === tag) {
      for (var attrName in attrs) {
        if (attrName === name && lowerValue === attrs[attrName]) {
          return true;
        }
      }
    }
  }
  return false;
}

/**
 * tag attribute only has name
 */
function isTagAttrOnlyName(attr) {
  return !!_config.tagAttrOnlyName[attr];
}
/**
 * attribute value no quote
 */
function isAttrValueNoQuote(value) {
  return (/^\w+$/.test(value)
  );
}

/**
 * check is optional end tag
 */
function isOptionalEndTag(tag, list) {
  list = list || _config.optionalEndTag;
  if (Array.isArray(list)) {
    return list.indexOf(tag) > -1;
  }
  return !!list[tag];
}

/**
 * check is void element
 */
function isVoidElement(tag) {
  return !!_config.voidElements[tag];
}
/**
 * is standard tag
 */
function isTag(tag) {
  return !!_config.allTags[tag];
}

/**
 * is safe tag
 */
function isSafeTag(tag) {
  return !!_config.safeTags[tag];
}
//# sourceMappingURL=util.js.map