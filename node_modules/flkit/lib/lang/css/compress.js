'use strict';

exports.__esModule = true;

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _base = require('../../util/base.js');

var _base2 = _interopRequireDefault(_base);

var _tokenize = require('./tokenize.js');

var _tokenize2 = _interopRequireDefault(_tokenize);

var _token_type = require('../../util/token_type.js');

var _token_type2 = _interopRequireDefault(_token_type);

var _selector_tokenize = require('./selector_tokenize.js');

var _selector_tokenize2 = _interopRequireDefault(_selector_tokenize);

var _util = require('./util.js');

var _util_ext = require('../../util/util_ext.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * default compress options
 */
var compressOpts = {
  removeComment: true,
  removeLastSemicolon: true,
  removeEmptySelector: true,
  overrideSameProperty: true,
  shortValue: true,
  mergeProperty: true,
  sortProperty: true,
  sortSelector: true,
  mergeSelector: true,
  propertyToLower: true
};
/**
 * compress css
 */

var CssCompress = function (_Base) {
  (0, _inherits3.default)(CssCompress, _Base);

  /**
   * constructor
   */
  function CssCompress(text) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, CssCompress);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Base.call(this, '', options));

    _this._optText = text;

    _this.tokens = [];
    _this.index = 0;
    _this.length = 0;

    _this.result = [];
    _this.selectors = {};
    _this.inKeyframes = false;

    _this.options = (0, _extends3.default)({}, compressOpts, _this.options);
    return _this;
  }
  /**
   * init tokens
   */


  CssCompress.prototype.initTokens = function initTokens() {
    if (typeof this._optText === 'string') {
      var instance = new _tokenize2.default(this._optText, this.options);
      this.tokens = instance.run();
    } else {
      this.tokens = this._optText;
    }
    this.length = this.tokens.length;
  };
  /**
   * compress css value
   */


  CssCompress.prototype.compressValue = function compressValue(value, property) {
    // remove comment
    value = value.replace(/\/\*.*?\*\//g, '');
    // remove newline
    value = value.replace(/\n+/g, '');
    // remove extra whitespace
    value = value.replace(/\s+/g, ' ');

    // get short value
    if (this.options.shortValue) {
      value = (0, _util.getShortValue)(value, property);
    }

    // if property is filter, can't replace `, ` to `,`
    // see http://www.imququ.com/post/the_bug_of_ie-matrix-filter.html
    if (property.toLowerCase() !== 'filter') {
      // remove whitespace after ,
      value = value.replace(/,\s+/g, ',');
      value = value.replace(/#([0-9a-fA-F])\1([0-9a-fA-F])\2([0-9a-fA-F])\3/g, '#$1$2$3');
    }

    // replace 0(px,em,%) with 0.
    value = value.replace(/(^|\s)(0)(?:px|em|%|in|cm|mm|pc|pt|ex|rem)/gi, '$1$2');
    // replace 0.6 to .6
    value = value.replace(/(^|\s)0\.(\d+)/g, '$1.$2');
    // replace 1.0 to 1
    value = value.replace(/(\d+)\.0(\s|$)/g, '$1$2');
    // replace .0 to 0
    value = value.replace(/(^|\s)\.(0)(\s|$)/g, '$1$2$3');
    // Shorten colors from #AABBCC to #ABC. Note that we want to make sure
    // the color is not preceded by either ", " or =. Indeed, the property
    //     filter: chroma(color="#FFFFFF");
    // would become
    //     filter: chroma(color="#FFF");
    // which makes the filter break in IE.
    // value = value.replace(/([^\"'=\s])(\s*)#([0-9a-fA-F])\3([0-9a-fA-F])\4([0-9a-fA-F])\5/ig, '$1$2#$3$4$5');
    return value;
  };
  /**
   * get selector properties
   */


  CssCompress.prototype.getSelectorProperties = function getSelectorProperties() {
    var braces = this.tokens[this.index++];
    if (!braces) {
      return {};
    }
    if (braces.type !== _token_type2.default.CSS_LEFT_BRACE) {
      throw new Error('after selector must be a {');
    }

    var attrs = {},
        pos = 0,
        key = '';
    var propertyToken = null,
        valueToken = null,
        tplToken = null;
    var hasTpl = false,
        hasHack = false;

    selectorCondition: while (this.index < this.length) {
      var token = this.tokens[this.index++];
      token = this.removeComment(token);
      switch (token.type) {
        case _token_type2.default.CSS_PROPERTY:
          key += this.options.propertyToLower ? token.value.toLowerCase() : token.value;
          if (!this.options.overrideSameProperty && key in attrs) {
            key += pos++;
          }
          if (this.options.propertyToLower) {
            token.ext.value = token.ext.value.toLowerCase();
            token.value = token.value.toLowerCase();
          }
          propertyToken = token;

          // has tplToken before property
          if (tplToken) {
            attrs[tplToken.value + '%' + pos++] = {
              value: tplToken
            };
            tplToken = null;
          }
          break;
        case _token_type2.default.CSS_VALUE:
          valueToken = token;
          break;
        case _token_type2.default.CSS_SEMICOLON:
        case _token_type2.default.CSS_RIGHT_BRACE:
          if (valueToken === null && tplToken && propertyToken) {
            valueToken = tplToken;
            tplToken = null;
          }

          // already has tplToken
          if (tplToken) {
            attrs[tplToken.value + '%' + pos++] = {
              value: tplToken
            };
            tplToken = null;
          }

          if (!propertyToken || !valueToken) {
            if (token.type === _token_type2.default.CSS_RIGHT_BRACE) {
              break selectorCondition;
            }
            break;
          }

          // propertyToken is tpl
          if (propertyToken.type === _token_type2.default.TPL) {
            attrs[propertyToken.value + '%' + pos++] = {
              property: propertyToken,
              value: valueToken
            };
            propertyToken = valueToken = null;
            if (token.type === _token_type2.default.CSS_RIGHT_BRACE) {
              break selectorCondition;
            }
            break;
          }

          // optimize css value
          if (valueToken.type === _token_type2.default.CSS_VALUE) {
            valueToken.ext.value = this.compressValue(valueToken.ext.value, propertyToken.ext.value);
            /**
             * for div{color:red;color:blue\9;}
             * if suffix in css value, can not override property.
             */
            key += valueToken.ext.suffix;
          }

          // multi same property
          // background:red;background:url(xx.png)
          if ((0, _util.isMultiSameProperty)(key, valueToken.value)) {
            key += '%' + pos++;
          }

          // already has tpl syntax, can not override property
          // div{<&if $name&>color:red;<&else&>color:blue;<&/if&>font-size:12px;}
          if (hasTpl) {
            key += '%' + pos++;
          }

          if (this.options.overrideSameProperty) {
            var _mergeProperties;

            attrs = (0, _util.mergeProperties)(attrs, (_mergeProperties = {}, _mergeProperties[key] = {
              property: propertyToken,
              value: valueToken
            }, _mergeProperties));
          } else {
            attrs[key] = {
              property: propertyToken,
              value: valueToken
            };
          }
          propertyToken = valueToken = null;
          // hasColon = false;
          key = '';

          if (token.type === _token_type2.default.CSS_RIGHT_BRACE) {
            break selectorCondition;
          }
          break;
        case _token_type2.default.CSS_BRACK_HACK:
          // for css hack [;color:red;]
          attrs[token.value + '%' + pos++] = {
            value: token
          };
          hasHack = true;
          break;
        case _token_type2.default.TPL:
          // already has tplToken
          if (tplToken) {
            attrs[token.value + '%' + pos++] = {
              value: tplToken
            };
          }
          tplToken = token;
          hasTpl = true;
          break;
        case _token_type2.default.CSS_COLON:
          // is tplToken before :
          if (!propertyToken && tplToken) {
            propertyToken = tplToken;
            tplToken = null;
          }
          // hasColon = true;
          break;
      }
    }
    if (!hasHack && !hasTpl) {
      if (this.options.sortProperty) {
        attrs = this.sortProperties(attrs);
      }
      if (this.options.mergeProperty) {
        attrs = this.mergePropertyChildren(attrs);
      }
    }
    return attrs;
  };
  /**
   * sort properties
   */


  CssCompress.prototype.sortProperties = function sortProperties(attrs) {
    return attrs;
  };
  /**
   * merge properties
   */


  CssCompress.prototype.mergePropertyChildren = function mergePropertyChildren(attrs) {
    attrs = (0, _util.mergePropertyChildren)(attrs, 'padding');
    attrs = (0, _util.mergePropertyChildren)(attrs, 'margin');
    return attrs;
  };
  /**
   * collect selector
   */


  CssCompress.prototype.collectSelector = function collectSelector(token) {
    var selectorPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    var attrs = this.getSelectorProperties();
    // remove empty selector
    if (this.options.removeEmptySelector && (0, _keys2.default)(attrs).length === 0) {
      return true;
    }
    if (!token.ext.group) {
      var instance = new _selector_tokenize2.default(token.value, this.options);
      token.ext = instance.run();
    }
    var detail = {
      attrs: attrs,
      selector: token,
      pos: selectorPos++
    };
    var selectorKey = (0, _util.selectorToken2Text)(token);
    token.value = selectorKey;
    if (selectorKey in this.selectors) {
      this.selectors[selectorKey].attrs = (0, _util.mergeProperties)(this.selectors[selectorKey].attrs, attrs);
    } else {
      this.selectors[selectorKey] = detail;
    }
  };
  /**
   * selector can combine
   */


  CssCompress.prototype.selectorCanCombine = function selectorCanCombine(selectors) {
    var list = ['-ms-', ':root', '-placeholder'];
    return selectors.every(function (selector) {
      return list.every(function (item) {
        return selector.selector.value.indexOf(item) === -1;
      });
    });
  };
  /**
   * get properties intersect in 2 selectors
   */


  CssCompress.prototype.getPropertiesIntersect = function getPropertiesIntersect(se1, se2) {
    var attrs1 = se1.attrs;
    var attrs2 = se2.attrs;
    var assoc = {};
    var assoclen = 0;
    for (var key in attrs1) {
      // only have value token
      if (!attrs1[key].property) {
        continue;
      }
      // not exist in attrs2
      if (!(key in attrs2)) {
        continue;
      }
      if (!attrs2[key].property) {
        continue;
      }
      var attrs1Value = attrs1[key].value.value;
      var attrs2Value = attrs2[key].value.value;
      // value not equal
      if (attrs1Value !== attrs2Value) {
        continue;
      }
      // property has prefix or value has suffix
      // if(attrs1[key].property.ext.prefix || attrs1[key].value.ext.suffix){
      //   continue;
      // }
      if (this.isUnMergeProperty(attrs1[key], attrs1, attrs2)) {
        continue;
      }
      assoc[key] = attrs1[key];
      // 2 chars is : and ;
      assoclen += attrs1[key].property.value.length + attrs1[key].value.value.length + 2;
    }
    var length = (0, _keys2.default)(assoc).length;
    if (length === 0) {
      return false;
    }
    if (length !== (0, _keys2.default)(attrs1).length && length !== (0, _keys2.default)(attrs2).length) {
      // 3 chars is `, { }`
      var selen = se1.selector.value.length + se2.selector.value.length + 3;
      if (selen >= assoclen) {
        return false;
      }
    }
    return assoc;
  };
  /**
   * check css value token equal
   */


  CssCompress.prototype.checkValueTokenEqual = function checkValueTokenEqual(item1, item2) {
    var ext1 = item1.ext;
    var ext2 = item2.ext;
    var list = ['prefix', 'suffix', 'value', 'important'];
    return list.every(function (item) {
      return ext1[item] === ext2[item];
    });
  };
  /**
   * is unmerge property
   */


  CssCompress.prototype.isUnMergeProperty = function isUnMergeProperty(item1, attrs1, attrs2) {
    var item1Property = item1.property.ext.value.toLowerCase();
    var item1PropertyPrefix = item1.property.ext.prefix;
    var item1Value = item1.value.ext.value;
    if ((0, _util.isUnMergeProperty)(item1Property, item1Value)) {
      return true;
    }
    // if(isUnSortProperty(item1Property)){
    //   return true;
    // }
    for (var key in attrs1) {
      var itemPropertyValue = attrs1[key].property.ext.value.toLowerCase();
      var itemPropertyPrefix = attrs1[key].property.ext.prefix;
      if (item1Property === itemPropertyValue) {
        if (item1PropertyPrefix !== itemPropertyPrefix) {
          return true;
        }
        if (!this.checkValueTokenEqual(item1.value, attrs1[key].value)) {
          return true;
        }
      }
      if (item1Property.indexOf('-') > -1) {
        if (item1Property.indexOf(itemPropertyValue + '-') > -1) {
          return true;
        }
      } else {
        if (itemPropertyValue.indexOf(item1Property + '-') > -1) {
          return true;
        }
      }
    }
    for (var _key in attrs2) {
      var _itemPropertyValue = attrs2[_key].property.ext.value.toLowerCase();
      var _itemPropertyPrefix = attrs2[_key].property.ext.prefix;
      if (item1Property === _itemPropertyValue) {
        if (item1PropertyPrefix !== _itemPropertyPrefix) {
          return true;
        }
        if (!this.checkValueTokenEqual(item1.value, attrs2[_key].value)) {
          return true;
        }
      }
      if (item1Property.indexOf('-') > -1) {
        if (item1Property.indexOf(_itemPropertyValue + '-') > -1) {
          return true;
        }
      } else {
        if (_itemPropertyValue.indexOf(item1Property + '-') > -1) {
          return true;
        }
      }
    }
    return false;
  };
  /**
   * get assoc selector token
   */


  CssCompress.prototype.getAssocSelectorToken = function getAssocSelectorToken(se1, se2) {
    var value = se1.value + ',' + se2.value;
    var token = (0, _util_ext.createToken)(_token_type2.default.CSS_SELECTOR, value, se1);
    var equal = false;
    if (se1.ext.specificityEqual && se2.ext.specificityEqual) {
      equal = se1.ext.minSpecificity === se2.ext.minSpecificity;
    }
    var group = se1.ext.group.concat(se2.ext.group);
    token.ext = {
      minSpecificity: Math.min(se1.ext.minSpecificity, se2.ext.minSpecificity),
      maxSpecificity: Math.max(se1.ext.maxSpecificity, se2.ext.maxSpecificity),
      specificityEqual: equal,
      group: group
    };
    return token;
  };
  /**
   * get selector intersect
   */


  CssCompress.prototype.getSelectorsIntersect = function getSelectorsIntersect(selectors) {
    while (1) {
      var length = selectors.length;
      if (length < 2) {
        break;
      }
      var result = [];
      var flag = false;
      for (var index = 0; index < length - 1; index++) {
        var assoc = null;
        if (this.selectorCanCombine([selectors[index], selectors[index + 1]])) {
          assoc = this.getPropertiesIntersect(selectors[index], selectors[index + 1]);
        }
        if (assoc) {
          for (var key in assoc) {
            delete selectors[index].attrs[key];
            delete selectors[index + 1].attrs[key];
          }
          flag = true;
          var assocSelectorToken = this.getAssocSelectorToken(selectors[index].selector, selectors[index + 1].selector);
          result.push({
            attrs: assoc,
            selector: assocSelectorToken
          });
        }
        if ((0, _keys2.default)(selectors[index].attrs).length) {
          result.push(selectors[index]);
        }
      }
      if ((0, _keys2.default)(selectors[length - 1].attrs).length) {
        result.push(selectors[length - 1]);
      }
      selectors = result;
      if (!flag) {
        break;
      }
    }
    return selectors;
  };
  /**
   * sort selectors
   */


  CssCompress.prototype.sortSelectors = function sortSelectors(selectors) {
    var cache = {};
    var length = selectors.length;

    var compare = function compare(se1, se2) {
      var se1Ext = se1.selector.ext;
      var se2Ext = se2.selector.ext;
      if (!se1Ext.specificityEqual || !se2Ext.specificityEqual) {
        if (se1Ext.minSpecificity > se2Ext.maxSpecificity) {
          return 1;
        } else if (se1Ext.maxSpecificity < se2Ext.minSpecificity) {
          return -1;
        }
        return se1.pos - se2.pos;
      }
      if (se1Ext.minSpecificity === se2Ext.minSpecificity) {
        return se1.pos - se2.pos;
      }
      return se1Ext.minSpecificity - se2Ext.minSpecificity;
    };
    var compareNeighbor = function compareNeighbor(i, j) {
      for (var k = i + 1; k < j; k++) {
        var key = k + '_' + j;
        if (!cache[key]) {
          cache[key] = compare(selectors[k], selectors[j]);
        }
        if (cache[key] < 0) {
          return false;
        }
      }
      return true;
    };

    for (var i = 0; i < length; i++) {
      for (var j = i + 1; j < length; j++) {
        var key = i + '_' + j;
        if (!cache[key]) {
          cache[key] = compare(selectors[i], selectors[j]);
        }
        if (cache[key] > 0 && compareNeighbor(i, j)) {
          var tmp = selectors[j];
          selectors[j] = selectors[i];
          selectors[i] = tmp;
        }
      }
    }
    return selectors;
  };
  /**
   * remove exist selector
   */


  CssCompress.prototype.compressSelectorToken = function compressSelectorToken(selector) {
    var group = selector.ext.group;
    if (group.length === 1) {
      return selector;
    }
    var keys = {},
        ret = [];
    group.forEach(function (item) {
      var key = (0, _util.selectorGroupToken2Text)(item);
      if (!(key in keys)) {
        ret.push(item);
        keys[key] = true;
      }
    });
    selector.ext.group = ret;
    return selector;
  };
  /**
   * selector to tokens
   */


  CssCompress.prototype.selectorToTokens = function selectorToTokens(selectors) {
    var _this2 = this;

    var ret = [];

    var leftBrace = (0, _util_ext.createToken)(_token_type2.default.CSS_LEFT_BRACE, '{');
    var colon = (0, _util_ext.createToken)(_token_type2.default.CSS_COLON, ':');
    var rightBrace = (0, _util_ext.createToken)(_token_type2.default.CSS_RIGHT_BRACE, '}');
    var semicolon = (0, _util_ext.createToken)(_token_type2.default.CSS_SEMICOLON, ';');

    selectors.forEach(function (item) {
      item.selector = _this2.compressSelectorToken(item.selector);
      ret.push(item.selector, leftBrace);
      var attrs = (0, _keys2.default)(item.attrs).map(function (key) {
        return item.attrs[key];
      });
      var length = attrs.length;
      attrs.forEach(function (attr, index) {
        if (attr.property) {
          ret.push(attr.property, colon);
        }
        ret.push(attr.value);
        if (attr.value.type !== _token_type2.default.TPL) {
          if (!_this2.options.removeLastSemicolon || index < length - 1) {
            ret.push(semicolon);
          }
        }
      });
      ret.push(rightBrace);
    });
    return ret;
  };
  /**
   * compress selector
   */


  CssCompress.prototype.compressSelector = function compressSelector() {
    var _this3 = this,
        _result;

    var keys = (0, _keys2.default)(this.selectors);
    if (keys.length === 0) {
      return;
    }
    var selectors = keys.map(function (key) {
      return _this3.selectors[key];
    });
    this.selectors = {};

    if (this.options.sortSelector) {
      selectors = this.sortSelectors(selectors);
    }

    var se = [],
        result = [];
    selectors.forEach(function (item) {
      if (item.selector.ext.specificityEqual) {
        se.push(item);
      } else {
        se = _this3.getSelectorsIntersect(se);
        result = result.concat(se);
        result.push(item);
        se = [];
      }
    });
    if (se.length) {
      se = this.getSelectorsIntersect(se);
      result = result.concat(se);
    }
    var tokens = this.selectorToTokens(result);
    (_result = this.result).push.apply(_result, tokens);
  };
  /**
   * remove comment
   */


  CssCompress.prototype.removeComment = function removeComment(token) {
    if (!this.options.removeComment) {
      return token;
    }
    var comments = [];
    token.commentBefore.forEach(function (item) {
      if (item.value.indexOf('/*!') === 0) {
        comments.push(item);
      }
    });
    token.commentBefore = comments;
    return token;
  };
  /**
   * run
   */


  CssCompress.prototype.run = function run() {
    var retTokens = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    this.initTokens();
    var hasCharset = false;
    var sortSelector = this.options.sortSelector;
    var sortProperty = this.options.sortProperty;
    var selectorPos = 0;
    var property = '';
    while (this.index < this.length) {
      var token = this.tokens[this.index++];
      token = this.removeComment(token);
      switch (token.type) {
        case _token_type2.default.CSS_SELECTOR:
          this.collectSelector(token, selectorPos++);
          break;
        case _token_type2.default.CSS_VALUE:
          token.ext.value = this.compressValue(token.ext.value, property);
          this.result.push(token);
          break;
        case _token_type2.default.CSS_RIGHT_BRACE:
          if (this.index > 1 && this.tokens[this.index - 2].type === _token_type2.default.CSS_RIGHT_BRACE) {
            this.compressSelector();
            this.options.sortProperty = sortProperty;
            this.options.sortSelector = sortSelector;
            this.inKeyframes = false;
            this.result.push(token);
            break;
          }
        case _token_type2.default.CSS_KEYFRAMES:
          this.options.sortSelector = false;
          this.options.sortProperty = false;
          this.inKeyframes = true;
        default:
          if ((0, _util.isAtType)(token.type)) {
            this.compressSelector();
          }
          if (token.type === _token_type2.default.CSS_PROPERTY) {
            property = token.ext.value.toLowerCase();
          }
          if (token.type === _token_type2.default.CSS_CHARSET) {
            if (!hasCharset) {
              this.result.push(token);
            }
            hasCharset = true;
          } else {
            this.result.push(token);
          }
      }
    }
    this.compressSelector();
    return retTokens ? this.result : (0, _util.token2Text)(this.result);
  };

  return CssCompress;
}(_base2.default);

exports.default = CssCompress;
//# sourceMappingURL=compress.js.map