'use strict';

exports.__esModule = true;
exports.selectorBreakChar = exports.isHackChar = undefined;

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

exports.isAttrChar = isAttrChar;
exports.calculateSelectorSpecificity = calculateSelectorSpecificity;
exports.isPseudoElement = isPseudoElement;
exports.selectorGroupToken2Text = selectorGroupToken2Text;
exports.selectorToken2Text = selectorToken2Text;
exports.token2Text = token2Text;
exports.short4NumValue = short4NumValue;
exports.rgb2Hex = rgb2Hex;
exports.getShortValue = getShortValue;
exports.isMultiSameProperty = isMultiSameProperty;
exports.mergeProperties = mergeProperties;
exports.isAtType = isAtType;
exports.isUnMergeProperty = isUnMergeProperty;
exports.isUnSortProperty = isUnSortProperty;
exports.mergePropertyChildren = mergePropertyChildren;

var _token_type = require('../../util/token_type.js');

var _token_type2 = _interopRequireDefault(_token_type);

var _selector_tokenize = require('./selector_tokenize.js');

var _selector_tokenize2 = _interopRequireDefault(_selector_tokenize);

var _util = require('../../util/util.js');

var _util_ext = require('../../util/util_ext.js');

var _config = require('./config.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * is attribute char
 * @return {Boolean} [description]
 */
function isAttrChar(code) {
  // >= a && <= z or -
  return code >= 0x61 && code <= 0x7a || code === 0x2d;
}

/**
 * Calculating a selector's specificity
 * @param  {Array} tokens [selector tokens]
 * @return {Number}        []
 */
function calculateSelectorSpecificity(tokens) {
  var i = 0,
      length = tokens.length,
      token = void 0,
      specificity = 0,
      instance = void 0;
  for (; i < length; i++) {
    token = tokens[i];
    switch (token.type) {
      case _token_type2.default.CSS_SELECTOR_ID:
        specificity += 100;
        break;
      case _token_type2.default.CSS_SELECTOR_TYPE:
      case _token_type2.default.CSS_SELECTOR_PSEUDO_ELEMENT:
        specificity += 1;
        break;
      case _token_type2.default.CSS_SELECTOR_CLASS:
      case _token_type2.default.CSS_SELECTOR_ATTRIBUTE:
        specificity += 10;
        break;
      case _token_type2.default.CSS_SELECTOR_PSEUDO_CLASS:
        if (/^:not\(/i.test(token.value)) {
          instance = new _selector_tokenize2.default(token.value.slice(5, -1));
          specificity += instance.run().group[0].specificity;
        } else {
          specificity += 10;
        }
        break;
    }
  }
  return specificity;
}
/**
 * is hack char
 */
var isHackChar = exports.isHackChar = (0, _util.makePredicate)(_config.propertyHackPrefix);
/**
 * selector char util
 */
var selectorBreakChar = exports.selectorBreakChar = (0, _util.makePredicate)(_config.selectorCharUntil);
/**
 * is pseudo elements
 */
function isPseudoElement(el) {
  return _config.pseudosElements21.indexOf(el) > -1;
}
/**
 * selector group token to text
 */
function selectorGroupToken2Text(selectorGroupToken) {
  return selectorGroupToken.tokens.map(function (token, index) {
    var hasSpace = false;
    if (index > 0) {
      hasSpace = (0, _util.hasSpaceBetweenTokens)(selectorGroupToken.tokens[index - 1], token);
    }
    return (hasSpace ? ' ' : '') + token.value;
  }).join('');
}
/**
 * selector token to text
 */
function selectorToken2Text(token) {
  return token.ext.group.map(function (item) {
    return selectorGroupToken2Text(item);
  }).join(',');
}
/**
 * tokens to text
 */
function token2Text(tokens) {
  var delimiters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  var prev = '';
  return tokens.map(function (token, index) {
    var prefix = token.commentBefore.map(function (item) {
      return item.value;
    }).join('');
    var value = '';
    switch (token.type) {
      case _token_type2.default.CSS_SELECTOR:
        value = selectorToken2Text(token);
        break;
      case _token_type2.default.CSS_PROPERTY:
        value = token.ext.prefix + token.ext.value + token.ext.suffix;
        break;
      case _token_type2.default.CSS_VALUE:
        value = token.ext.prefix + token.ext.value + token.ext.suffix;
        if (token.ext.important) {
          value += '!important';
        }
        break;
      default:
        value = token.value;
        break;
    }
    if (!prefix && index > 0) {
      var combineChars = prev[prev.length - 1] + value[0];
      if (delimiters.indexOf(combineChars) > -1) {
        value = ' ' + value;
      }
    }
    prev = prefix + value;
    return prev;
  }).join('');
}

/**
 * short for num value
 * margin: 10px 20px 10px 20px;
 */
function short4NumValue(value) {
  var append = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var returnArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (!Array.isArray(value)) {
    value = value.split(/ +/);
  }
  var length = value.length;
  var v = [[], [0, 0, 0, 0], [0, 1, 0, 1], [0, 1, 2, 1], [0, 1, 2, 3]];
  var sv = v[length];
  value = [value[sv[0]], value[sv[1]], value[sv[2]], value[sv[3]]];
  for (var index in append) {
    value[index | 0] = append[index];
  }
  if (value[1] === value[3]) {
    value.splice(3, 1);
  }
  if (value.length === 3 && value[0] === value[2]) {
    value.splice(2, 1);
  }
  if (value.length === 2 && value[0] === value[1]) {
    value.splice(1, 1);
  }
  if (returnArray) {
    return value;
  }
  return value.join(' ').trim();
}
/**
 * rgb to hex
 */
function rgb2Hex(value, r, g, b) {
  if (value === true) {
    var v = [r | 0, g | 0, b | 0];
    var result = '#';
    v.forEach(function (item) {
      result += (item < 16 ? '0' : '') + item.toString(16);
    });
    return result;
  }
  if (value.indexOf('rgb') === -1) {
    return value;
  }
  var rgbRex = /rgb\s*\(\s*(\d+)\s*\,\s*(\d+)\s*\,\s*(\d+)\s*\)/g;
  value = value.replace(rgbRex, function (a, r, g, b) {
    return rgb2Hex(true, r, g, b);
  });
  return value;
}
/**
 * get short value
 */
function getShortValue(value, property) {
  // http://www.w3schools.com/cssref/pr_border-width.asp
  property = property.toLowerCase();
  if (property === 'border-color' || property === 'border-style' || property === 'border-width') {
    if (value.indexOf('(') === -1) {
      return short4NumValue(value);
    }
  }
  var list = {
    color: _config.shortColor,
    'border-top-color': _config.shortColor,
    'border-left-color': _config.shortColor,
    'border-right-color': _config.shortColor,
    'border-bottom-color': _config.shortColor,
    'background-color': _config.shortColor,
    'font-weight': _config.shortFontWeight
  };
  // rgb(0,0,0) -> #000000 (or #000 in this case later)
  value = rgb2Hex(value);
  if (property in list) {
    return list[property][value] || value;
  }
  return value;
}

/**
 * is multi same property
 */
function isMultiSameProperty(property, value) {
  if (value.indexOf('calc') > -1) {
    return true;
  }
  return !!_config.multiSameProperty[property];
}
/**
 * merge properties
 */
function mergeProperties(attrs1, attrs2) {
  for (var key in attrs2) {
    if (attrs1[key]) {
      if (!attrs1[key].value.ext.important || attrs2[key].value.ext.important) {
        delete attrs1[key];
        attrs1[key] = attrs2[key];
      }
    } else {
      attrs1[key] = attrs2[key];
    }
  }
  return attrs1;
}
/**
 * is @ type
 */
function isAtType(type) {
  return !!_config.atTypes[type];
}
/**
 * can not merged property
 */
function isUnMergeProperty(property, value) {
  var v = _config.unMergeProperties[property.toLowerCase()];
  if (!v) {
    return false;
  }
  if (typeof v === 'boolean') {
    return v;
  }
  return v.test(value);
}
/**
 * is unsort property
 */
function isUnSortProperty(property) {
  return _config.unSortProperties.some(function (item) {
    return item === property || property.indexOf(item + '-') > -1;
  });
}

/**
 * combine property
 *
 *  a{padding: 10px; padding-left: 20px;} => a{padding: 20px 10px 10px 10px}
 */
function mergePropertyChildren(attrs) {
  var _properties;

  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'padding';

  var list = _config.propertyChildren[type];
  var properties = (_properties = {}, _properties[type] = 0, _properties);
  list.forEach(function (item) {
    return properties[item] = 0;
  });

  for (var key in attrs) {
    var _attrs$key = attrs[key],
        property = _attrs$key.property,
        value = _attrs$key.value;
    // if has tpl or hack in attrs, can not combine it

    if (!property || property.type === _token_type2.default.TPL || value.type === _token_type2.default.TPL || value.type === _token_type2.default.CSS_BRACK_HACK) {
      return attrs;
    }
    var propertyValue = property.value.toLowerCase();
    if (propertyValue !== key) return attrs;
    if (propertyValue in properties) {
      if (property.ext.prefix || value.ext.suffix || value.ext.important || value.ext.prefix) {
        return attrs;
      } else {
        properties[propertyValue] = 1;
      }
    }
  }
  if (properties[type]) {
    /**
     * 避免出现这种情况
     *
    .manage-content {
        padding-top: 20px;
        background: #fff;
        padding: 0 26px 20px;
    }
    */
    var attrsKeys = (0, _keys2.default)(attrs);
    var mainIndex = attrsKeys.indexOf(type);
    var append = {};
    var value = attrs[type].value.ext.value;
    list.forEach(function (item, index) {
      if (properties[item]) {
        var idx = attrsKeys.indexOf(item);
        if (idx > mainIndex) {
          append[index] = attrs[item].value.value;
        }
        delete attrs[item];
      }
    });
    attrs[type].value.ext.value = short4NumValue(value, append);
    attrs[type].value.value = attrs[type].value.ext.value;
  } else {
    var flag = list.every(function (item) {
      return properties[item];
    });
    if (!flag) {
      return attrs;
    }
    var _value = [];
    list.forEach(function (item, index) {
      _value[index] = attrs[item].value.ext.value;
      delete attrs[item];
    });
    var propertyToken = (0, _util_ext.createToken)(_token_type2.default.CSS_PROPERTY, type);
    propertyToken.ext = {
      prefix: '',
      value: type,
      suffix: ''
    };
    var shortValue = short4NumValue(_value);
    var valueToken = (0, _util_ext.createToken)(_token_type2.default.CSS_VALUE, shortValue);
    valueToken.ext = {
      prefix: '',
      value: shortValue,
      suffix: '',
      important: false
    };
    attrs[type] = {
      property: propertyToken,
      value: valueToken
    };
  }
  return attrs;
}
//# sourceMappingURL=util.js.map