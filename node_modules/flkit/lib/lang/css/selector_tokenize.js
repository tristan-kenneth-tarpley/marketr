'use strict';

exports.__esModule = true;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _tokenize = require('../../util/tokenize.js');

var _tokenize2 = _interopRequireDefault(_tokenize);

var _token_type = require('../../util/token_type.js');

var _token_type2 = _interopRequireDefault(_token_type);

var _util = require('./util.js');

var _config = require('./config.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * css selector tokenize
 * https://www.w3.org/TR/css3-selectors/#lex
 */
var CssSelectorTokenize = function (_Base) {
  (0, _inherits3.default)(CssSelectorTokenize, _Base);

  /**
   * constructor
   */
  function CssSelectorTokenize(text, options) {
    (0, _classCallCheck3.default)(this, CssSelectorTokenize);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Base.call(this, text, options));

    _this.prevToken = null;
    return _this;
  }
  /**
   * get next token
   * @return {Object} []
   */


  CssSelectorTokenize.prototype.getNextToken = function getNextToken() {
    var token = _Base.prototype.getNextToken.call(this);
    if (token || token === false) {
      return token;
    }
    if (!this.prevToken || this.prevToken.type === _token_type2.default.CSS_SELECTOR_COMMA) {
      var match = this.text.match(_config.namespaceReg);
      if (match) {
        this.forward(match[0].length);
        return this.getToken(_token_type2.default.CSS_SELECTOR_NAMESPACE, match[0]);
      }
    }
    var code = this.text.charCodeAt(this.pos);
    switch (code) {
      case 0x2a:
        // *
        return this.getToken(_token_type2.default.CSS_SELECTOR_UNIVERSAL, this.next());
      case 0x2c:
        // ,
        return this.getToken(_token_type2.default.CSS_SELECTOR_COMMA, this.next());
      case 0x3e: // >
      case 0x2b: // +
      case 0x7e:
        // ~
        return this.getToken(_token_type2.default.CSS_SELECTOR_COMBINATOR, this.next());
      case 0x23:
        // #
        return this.getCommonToken(_token_type2.default.CSS_SELECTOR_ID);
      case 0x2e:
        // .
        return this.getCommonToken(_token_type2.default.CSS_SELECTOR_CLASS);
      case 0x5b:
        // [
        return this.getAttributeToken();
      case 0x3a:
        // :
        if (this.text.charCodeAt(this.pos + 1) === 0x3a) {
          this.next();
          token = this.getCommonToken(_token_type2.default.CSS_SELECTOR_PSEUDO_ELEMENT);
          token.value = ':' + token.value;
          token.vender = token.value.charCodeAt(2) === 0x2d;
          return token;
        }
        return this.getPseudoClassToken();
      default:
        return this.getCommonToken(_token_type2.default.CSS_SELECTOR_TYPE);
    }
    // return false;
  };
  /**
   * skip comment
   * @return {void} []
   */


  CssSelectorTokenize.prototype.skipComment = function skipComment() {
    // start with /*
    var comment = void 0;
    while (this.text.charCodeAt(this.pos) === 0x2f && this.text.charCodeAt(this.pos + 1) === 0x2a) {
      comment = this.getCommentToken(1, true);
      this.commentBefore.push(comment);
    }
  };
  /**
   * get common token
   * @param  {Number} type []
   * @return {Object}      []
   */


  CssSelectorTokenize.prototype.getCommonToken = function getCommonToken(type) {
    var ret = this.next(),
        code = void 0;
    while (this.pos < this.length) {
      code = this.text.charCodeAt(this.pos);
      if ((0, _util.selectorBreakChar)(code) || this.isWhiteSpace(code)) {
        break;
      }
      ret += this.next();
    }
    return this.getToken(type, ret);
  };
  /**
   * get attribute token
   * @return {Object} []
   */


  CssSelectorTokenize.prototype.getAttributeToken = function getAttributeToken() {
    var ret = this.getMatchedChar(0x5b, 0x5d, {
      quote: true
    });
    return this.getToken(_token_type2.default.CSS_SELECTOR_ATTRIBUTE, ret);
  };
  /**
   * get pseudo class token, support :not(xxx)
   * @return {Object} []
   */


  CssSelectorTokenize.prototype.getPseudoClassToken = function getPseudoClassToken() {
    var ret = this.next(),
        code = void 0;
    while (this.pos < this.length) {
      code = this.text.charCodeAt(this.pos);
      if (code === 0x28) {
        ret += this.getMatchedChar(0x28, 0x29, {
          nest: true,
          quote: true
        });
        continue;
      }
      if ((0, _util.selectorBreakChar)(code) || this.isWhiteSpace(code)) {
        break;
      }
      ret += this.next();
    }
    if ((0, _util.isPseudoElement)(ret)) {
      return this.getToken(_token_type2.default.CSS_SELECTOR_PSEUDO_ELEMENT, ret);
    }
    var token = this.getToken(_token_type2.default.CSS_SELECTOR_PSEUDO_CLASS, ret);
    token.vender = token.value.charCodeAt(1) === 0x2d;
    return token;
  };
  /**
   * check token valid
   * @param  {Object} token []
   * @return {Boolean}       []
   */


  CssSelectorTokenize.prototype.checkInvalid = function checkInvalid(token) {
    switch (token.type) {
      case _token_type2.default.CSS_SELECTOR_CLASS:
        if (token.value.length === 1) {
          return true;
        }
        break;
    }
  };
  /**
   * run
   * @return {Object} []
   */


  CssSelectorTokenize.prototype.run = function run() {
    var result = [],
        tokens = [],
        token = void 0,
        min = -1,
        max = -1;
    var specificity = void 0,
        invalid = false,
        vender = false;
    for (; token = this.getNextToken();) {
      this.prevToken = token;
      if (token.type === _token_type2.default.CSS_SELECTOR_COMMA) {
        specificity = (0, _util.calculateSelectorSpecificity)(tokens);
        if (min === -1) {
          min = max = specificity;
        } else {
          if (specificity < min) {
            min = specificity;
          }
          if (specificity > max) {
            max = specificity;
          }
        }
        result.push({
          tokens: tokens,
          specificity: specificity
        });
        tokens = [];
      } else {
        if (!vender) {
          vender = token.vender;
        }
        if (!invalid) {
          invalid = this.checkInvalid(token);
        }
        tokens.push(token);
      }
    }
    if (tokens.length) {
      specificity = (0, _util.calculateSelectorSpecificity)(tokens);
      if (min === -1) {
        min = max = specificity;
      } else {
        if (specificity < min) {
          min = specificity;
        }
        if (specificity > max) {
          max = specificity;
        }
      }
      result.push({
        tokens: tokens,
        specificity: specificity
      });
    }
    var data = {
      minSpecificity: min,
      maxSpecificity: max,
      specificityEqual: min === max,
      hasVender: !!vender,
      group: result
    };
    if (invalid) {
      data.invalid = true;
    }
    return data;
  };

  return CssSelectorTokenize;
}(_tokenize2.default);

exports.default = CssSelectorTokenize;
//# sourceMappingURL=selector_tokenize.js.map