'use strict';

exports.__esModule = true;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _base = require('./base.js');

var _base2 = _interopRequireDefault(_base);

var _util = require('./util.js');

var _config = require('./config.js');

var _error = require('./error.js');

var _error2 = _interopRequireDefault(_error);

var _message = require('./message.js');

var _message2 = _interopRequireDefault(_message);

var _token_type = require('./token_type.js');

var _token_type2 = _interopRequireDefault(_token_type);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var lineComments = _config.comments[0];

var Tokenize = function (_Base) {
  (0, _inherits3.default)(Tokenize, _Base);

  /**
   * constructor
   * @param  {String} text    []
   * @param  {Object} options []
   * @return {void}         []
   */
  function Tokenize(text, options) {
    (0, _classCallCheck3.default)(this, Tokenize);

    var _this = (0, _possibleConstructorReturn3.default)(this, _Base.call(this, text, options));

    _this.pos = 0;
    _this._pos = 0;
    _this.line = 0;
    _this._line = 0;
    _this.col = 0;
    _this._col = 0;
    // this.newlineBefore = 0;
    // this._newlineBefore = 0;
    // this.spaceBefore = 0;
    // this._spaceBefore = 0;
    _this.commentBefore = [];
    return _this;
  }
  /**
   * get next char
   * @return {Function} [next char from text]
   */


  Tokenize.prototype.next = function next() {
    var chr = this.text[this.pos++];
    // 0x0a is \n
    if (chr.charCodeAt(0) === 0x0a) {
      this.line++;
      this.col = 0;
      // this.newlineBefore++;
    } else {
      this.col++;
    }
    return chr;
  };
  /**
   * forward num chars
   * @param  {Number} i []
   * @return {String}   [forward string]
   */


  Tokenize.prototype.forward = function forward(i) {
    var ret = '';
    while (i-- > 0) {
      ret += this.next();
    }
    return ret;
  };
  /**
   * forward to char
   * @param  {String} chr []
   * @return {String}     []
   */


  Tokenize.prototype.forwardChar = function forwardChar(chr, contain) {
    var pos = this._text.indexOf(chr, this.pos);
    if (pos === -1) {
      return '';
    }
    var str = this.forward(pos - this.pos + (contain !== false ? 1 : 0));
    return str;
  };
  /**
   * skip whitespace
   * @return {void} []
   */


  Tokenize.prototype.skipWhiteSpace = function skipWhiteSpace() {
    // let whitespace = this.whitespace;
    while (this.isWhiteSpace(this.text.charCodeAt(this.pos))) {
      this.spaceBefore++;
      this.next();
    }
  };
  /**
   * check char is whitespace
   */


  Tokenize.prototype.isWhiteSpace = function isWhiteSpace(chr) {
    return (0, _util.isWhiteSpace)(chr);
  };
  /**
   * skip comment
   * sub class override
   * @return {void} []
   */


  Tokenize.prototype.skipComment = function skipComment() {};
  /**
   * skip right space for text
   * @param  {String} value []
   * @return {String}       []
   */


  Tokenize.prototype.skipRightSpace = function skipRightSpace(value) {
    var length = value.length,
        index = length - 1;
    var newlines = 0,
        spaces = 0,
        chr = void 0,
        code = void 0;
    while (index >= 0) {
      chr = value[index];
      code = chr.charCodeAt(0);
      if (this.isWhiteSpace(code)) {
        index--;
        spaces++;
        if (code === 0x0a) {
          newlines++;
        }
        continue;
      }
      break;
    }
    // this.newlineBefore += newlines;
    // this.spaceBefore += spaces;
    return value.slice(0, index + 1);
  };
  /**
   * skip cdo and cdc string
   * @return {void} []
   */


  Tokenize.prototype.skipCd = function skipCd() {
    if (this.lookAt(_config.cdo)) {
      this.forward(4);
      this.length -= 3;
    }
  };
  /**
   * look at string in current position
   * @param  {String} str           []
   * @return {Boolean}              []
   */


  Tokenize.prototype.lookAt = function lookAt(str) {
    return str === this._text.substr(this.pos, str.length);
  };
  /**
   * find string, support escape
   * @param  {String} str [find string in text]
   * @return {Number}     [string pos in text]
   */


  Tokenize.prototype.find = function find(str) {
    var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    return this._text.indexOf(str, this.pos + forward);
  };
  /**
   * throw error
   * @param  {String} message []
   * @param  {Number} line    []
   * @param  {Number} col     []
   * @return {void}         []
   */


  Tokenize.prototype.error = function error(message, useRecord) {
    if (useRecord) {
      throw new _error2.default(message, this._record.line, this._record.col);
    } else {
      throw new _error2.default(message, this.line, this.col);
    }
  };
  /**
   * record line & col & pos
   * @return {void} []
   */


  Tokenize.prototype.record = function record() {
    this._record = {
      line: this.line,
      col: this.col,
      pos: this.pos
      // newlineBefore: this.newlineBefore,
      // spaceBefore: this.spaceBefore
    };
    return this._record;
  };
  /**
   * rollback parse
   * @return {void} []
   */


  Tokenize.prototype.rollback = function rollback(record) {
    record = record || this._record;
    if (!record) {
      return false;
    }
    this.line = record.line;
    this.col = record.col;
    this.pos = record.pos;
    // this.newlineBefore = record.newlineBefore;
    // this.spaceBefore = record.spaceBefore;
  };
  /**
   * get quote text, support template syntax in quote
   * @return {String} [quote string]
   */


  Tokenize.prototype.getQuote = function getQuote() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var quote = this.next(),
        quoteCode = quote.charCodeAt(0);
    var ret = quote,
        find = false,
        tpl = void 0,
        code = void 0,
        chr = void 0;
    var supportEscape = options.escape,
        escape = false;
    this.record();
    /* jshint -W084 */
    while (this.pos < this.length) {
      // template syntax in quote string
      tpl = this.getTplToken();
      if (tpl) {
        ret += tpl.value;
        continue;
      }
      chr = this.text[this.pos];
      code = chr.charCodeAt(0);
      if (supportEscape && (code === 0x5c || escape)) {
        escape = !escape;
        ret += this.next();
        continue;
      }
      // chr is quote, but next chr is not
      if (!escape && code === quoteCode) {
        if (!options.checkNext || this.text.charCodeAt(this.pos + 1) !== code) {
          find = true;
          ret += this.next();
          break;
        }
      }
      ret += this.next();
    }
    if (!find) {
      if (options.throwError) {
        this.error(_message2.default.UnMatchedQuoteChar, true);
      } else if (options.rollback) {
        this.rollback();
        return {
          value: quote,
          find: false
        };
      }
    }
    return {
      value: ret,
      find: find
    };
  };
  /**
   * get matched string
   * not supoort tpl, nested, quote
   * @param  {String} start []
   * @param  {String} end   []
   * @return {String}       []
   */


  Tokenize.prototype.getMatched = function getMatched(start, end) {
    if (!this.lookAt(start)) {
      return false;
    }
    var startLength = start.length,
        endLength = end.length;
    var pos = this.find(end, startLength);
    // can't find end string in text
    if (pos === -1) {
      return false;
    }
    return this.forward(pos - this.pos + endLength);
  };
  /**
   * get match char, such as: [], (), {}
   * @param  {Number} startCode [start char]
   * @param  {Number} endCode   [end char]
   * @return {String}           [matched char]
   */


  Tokenize.prototype.getMatchedChar = function getMatchedChar(startCode, endCode) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (this._text.charCodeAt(this.pos) !== startCode) {
      return false;
    }
    var code = void 0,
        nextCode = void 0,
        comment = void 0,
        nums = 0;
    var ret = this.next(),
        chr = void 0;
    var quote = options.quote;
    var multi_comment = options.multi_comment;
    var line_comment = options.line_comment;
    var nest = options.nest;
    var supportEscape = options.escape,
        escape = false;

    while (this.pos < this.length) {
      chr = this.text[this.pos];
      code = chr.charCodeAt(0);
      if (supportEscape && (code === 0x5c || escape)) {
        escape = !escape;
        ret += this.next();
        continue;
      }
      if (quote && !escape && (code === 0x22 || code === 0x27)) {
        ret += this.getQuote({
          rollback: true
        }).value;
        continue;
      }
      if (code === 0x2f) {
        nextCode = this.text.charCodeAt(this.pos + 1);
        comment = '';
        if (multi_comment && nextCode === 0x2a) {
          comment = this.getCommentToken(1, false);
        } else if (line_comment && nextCode === 0x2f) {
          comment = this.getCommentToken(0, false);
        }
        if (comment) {
          ret += comment.value;
          continue;
        }
      }
      if (nest && code === startCode) {
        nums++;
      } else if (code === endCode) {
        if (!nest || nums === 0) {
          ret += this.next();
          return ret;
        }
        nums--;
      }
      ret += this.next();
    }
    return ret;
  };
  /**
   * start token
   * @return {void} []
   */


  Tokenize.prototype.startToken = function startToken() {
    this._line = this.line;
    this._col = this.col;
    this._pos = this.pos;
    // this._newlineBefore = this.newlineBefore;
    // this._spaceBefore = this.spaceBefore;
  };
  /**
   * get template token
   * @return {Object} []
   */


  Tokenize.prototype.getTplToken = function getTplToken() {
    if (!this._hasTpl) {
      return false;
    }
    var length = this.ld.length,
        ld = void 0,
        rd = void 0,
        tplInstance = this.getTplInstance();
    var ret = void 0,
        value = void 0;
    for (var i = 0; i < length; i++) {
      ld = this.ld[i];
      rd = this.rd[i];
      ret = tplInstance.getMatched(ld, rd, this);
      if (ret) {
        if (ret.slice(0 - rd.length) === rd) {
          value = ret.slice(ld.length, 0 - rd.length);
        } else {
          value = ret.slice(ld.length);
        }
        return this.getToken(_token_type2.default.TPL, ret, {
          ld: ld,
          rd: rd,
          value: value
        });
      }
    }
    return false;
  };
  /**
   * check next chars is template syntax
   * @return {Boolean} []
   */


  Tokenize.prototype.isTplNext = function isTplNext() {
    if (!this._hasTpl) {
      return false;
    }
    var length = this.ld.length;
    for (var i = 0; i < length; i++) {
      if (this.lookAt(this.ld[i])) {
        return true;
      }
    }
    return false;
  };
  /**
   * get next token
   * @return {Object} []
   */


  Tokenize.prototype.getNextToken = function getNextToken() {
    this.skipWhiteSpace();
    this.skipComment();
    this.startToken();
    var token = this.getTplToken();
    if (token !== false) {
      return token;
    }
    if (this.pos >= this.length) {
      return this.getLastToken();
    }
  };
  /**
   * get token info
   * @param  {String} type  []
   * @param  {String} value []
   * @return {Object}       []
   */


  Tokenize.prototype.getToken = function getToken(type, value, extra) {
    var data = {
      type: type,
      value: value || '',
      start: this._pos,
      end: this.pos,
      loc: {
        start: {
          line: this._line,
          column: this._col
        },
        end: {
          line: this.line,
          column: this.col
        }
      },
      // newlineBefore: this._newlineBefore,
      // spaceBefore: this._spaceBefore,
      commentBefore: this.commentBefore,
      ext: {}
    };
    if (extra) {
      for (var key in extra) {
        data.ext[key] = extra[key];
      }
    }
    // this.newlineBefore = this.spaceBefore = 0;
    this.commentBefore = [];
    return data;
  };
  /**
   * get last token
   * @return {Object} []
   */


  Tokenize.prototype.getLastToken = function getLastToken() {
    if (this.commentBefore.length) {
      return this.getToken(_token_type2.default.EOS);
    }
    return false;
  };
  /**
   * get comment string
   * @param  {String} type           []
   * @return {Object}                []
   */


  Tokenize.prototype.getCommentToken = function getCommentToken(type, skipWhiteSpace /*, inText */) {
    this.record();
    var result = void 0;
    if (type === 0) {
      result = this.getLineComment();
    } else {
      var value = _config.comments[type];
      result = this.getMatched(value[0], value[1]);
    }
    if (!result) {
      return false;
    }
    var data = {
      value: result,
      start: this._record.pos,
      end: this.pos,
      loc: {
        start: {
          line: this._record.line,
          column: this._record.col
        },
        end: {
          line: this.line,
          column: this.col
        }
        // newlineBefore: this._record.newlineBefore,
        // spaceBefore: this._record.spaceBefore
      } };
    // if (inText) {
    //   //data.newlineBefore = data.spaceBefore = 0;
    // }
    // this.newlineBefore = this.spaceBefore = 0;
    if (skipWhiteSpace !== false) {
      this.skipWhiteSpace();
    }
    return data;
  };
  /**
   * get line comment
   * @return {Object} []
   */


  Tokenize.prototype.getLineComment = function getLineComment() {
    if (!this.lookAt(lineComments[0])) {
      return;
    }
    var ret = this.forward(lineComments[0].length);
    var chr = void 0,
        code = void 0;
    while (this.pos < this.length) {
      chr = this.text[this.pos];
      code = chr.charCodeAt(0);
      if (code === 0x0a) {
        break;
      }
      ret += this.next();
    }
    return ret;
  };
  /**
   * run
   * @return {Array} [text tokens]
   */


  Tokenize.prototype.run = function run() {
    var ret = [],
        token = void 0;
    while (token = this.getNextToken()) {
      ret.push(token);
    }
    return ret;
  };

  return Tokenize;
}(_base2.default);

exports.default = Tokenize;
//# sourceMappingURL=tokenize.js.map