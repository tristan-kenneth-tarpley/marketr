{"version":3,"sources":["../../src/util/tokenize.js"],"names":["lineComments","Tokenize","text","options","pos","_pos","line","_line","col","_col","commentBefore","next","chr","charCodeAt","forward","i","ret","forwardChar","contain","_text","indexOf","str","skipWhiteSpace","isWhiteSpace","spaceBefore","skipComment","skipRightSpace","value","length","index","newlines","spaces","code","slice","skipCd","lookAt","substr","find","error","message","useRecord","_record","record","rollback","getQuote","quote","quoteCode","tpl","supportEscape","escape","getTplToken","checkNext","throwError","UnMatchedQuoteChar","getMatched","start","end","startLength","endLength","getMatchedChar","startCode","endCode","nextCode","comment","nums","multi_comment","line_comment","nest","getCommentToken","startToken","_hasTpl","ld","rd","tplInstance","getTplInstance","getToken","TPL","isTplNext","getNextToken","token","getLastToken","type","extra","data","loc","column","ext","key","EOS","result","getLineComment","run","push"],"mappings":"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","file":"tokenize.js","sourcesContent":["import Base from './base.js';\nimport {isWhiteSpace} from './util.js';\nimport {cdo, comments} from './config.js';\nimport Err from './error.js';\nimport Message from './message.js';\nimport TokenType from './token_type.js';\n\nconst lineComments = comments[0];\n\nexport default class Tokenize extends Base {\n  /**\n   * constructor\n   * @param  {String} text    []\n   * @param  {Object} options []\n   * @return {void}         []\n   */\n  constructor(text, options) {\n    super(text, options);\n    this.pos = 0;\n    this._pos = 0;\n    this.line = 0;\n    this._line = 0;\n    this.col = 0;\n    this._col = 0;\n    // this.newlineBefore = 0;\n    // this._newlineBefore = 0;\n    // this.spaceBefore = 0;\n    // this._spaceBefore = 0;\n    this.commentBefore = [];\n  }\n  /**\n   * get next char\n   * @return {Function} [next char from text]\n   */\n  next() {\n    const chr = this.text[this.pos++];\n    // 0x0a is \\n\n    if (chr.charCodeAt(0) === 0x0a) {\n      this.line++;\n      this.col = 0;\n      // this.newlineBefore++;\n    } else {\n      this.col++;\n    }\n    return chr;\n  }\n  /**\n   * forward num chars\n   * @param  {Number} i []\n   * @return {String}   [forward string]\n   */\n  forward(i) {\n    let ret = '';\n    while (i-- > 0) {\n      ret += this.next();\n    }\n    return ret;\n  }\n  /**\n   * forward to char\n   * @param  {String} chr []\n   * @return {String}     []\n   */\n  forwardChar(chr, contain) {\n    const pos = this._text.indexOf(chr, this.pos);\n    if (pos === -1) {\n      return '';\n    }\n    const str = this.forward(pos - this.pos + (contain !== false ? 1 : 0));\n    return str;\n  }\n  /**\n   * skip whitespace\n   * @return {void} []\n   */\n  skipWhiteSpace() {\n    // let whitespace = this.whitespace;\n    while (this.isWhiteSpace(this.text.charCodeAt(this.pos))) {\n      this.spaceBefore++;\n      this.next();\n    }\n  }\n  /**\n   * check char is whitespace\n   */\n  isWhiteSpace(chr) {\n    return isWhiteSpace(chr);\n  }\n  /**\n   * skip comment\n   * sub class override\n   * @return {void} []\n   */\n  skipComment() {\n\n  }\n  /**\n   * skip right space for text\n   * @param  {String} value []\n   * @return {String}       []\n   */\n  skipRightSpace(value) {\n    let length = value.length, index = length - 1;\n    let newlines = 0, spaces = 0, chr, code;\n    while (index >= 0) {\n      chr = value[index];\n      code = chr.charCodeAt(0);\n      if (this.isWhiteSpace(code)) {\n        index--;\n        spaces++;\n        if (code === 0x0a) {\n          newlines++;\n        }\n        continue;\n      }\n      break;\n    }\n    // this.newlineBefore += newlines;\n    // this.spaceBefore += spaces;\n    return value.slice(0, index + 1);\n  }\n  /**\n   * skip cdo and cdc string\n   * @return {void} []\n   */\n  skipCd() {\n    if (this.lookAt(cdo)) {\n      this.forward(4);\n      this.length -= 3;\n    }\n  }\n  /**\n   * look at string in current position\n   * @param  {String} str           []\n   * @return {Boolean}              []\n   */\n  lookAt(str) {\n    return str === this._text.substr(this.pos, str.length);\n  }\n  /**\n   * find string, support escape\n   * @param  {String} str [find string in text]\n   * @return {Number}     [string pos in text]\n   */\n  find(str, forward = 0) {\n    return this._text.indexOf(str, this.pos + forward);\n  }\n  /**\n   * throw error\n   * @param  {String} message []\n   * @param  {Number} line    []\n   * @param  {Number} col     []\n   * @return {void}         []\n   */\n  error(message, useRecord) {\n    if (useRecord) {\n      throw new Err(message, this._record.line, this._record.col);\n    } else {\n      throw new Err(message, this.line, this.col);\n    }\n  }\n  /**\n   * record line & col & pos\n   * @return {void} []\n   */\n  record() {\n    this._record = {\n      line: this.line,\n      col: this.col,\n      pos: this.pos\n      // newlineBefore: this.newlineBefore,\n      // spaceBefore: this.spaceBefore\n    };\n    return this._record;\n  }\n  /**\n   * rollback parse\n   * @return {void} []\n   */\n  rollback(record) {\n    record = record || this._record;\n    if (!record) {\n      return false;\n    }\n    this.line = record.line;\n    this.col = record.col;\n    this.pos = record.pos;\n    // this.newlineBefore = record.newlineBefore;\n    // this.spaceBefore = record.spaceBefore;\n  }\n  /**\n   * get quote text, support template syntax in quote\n   * @return {String} [quote string]\n   */\n  getQuote(options = {}) {\n    let quote = this.next(), quoteCode = quote.charCodeAt(0);\n    let ret = quote, find = false, tpl, code, chr;\n    let supportEscape = options.escape, escape = false;\n    this.record();\n    /* jshint -W084 */\n    while (this.pos < this.length) {\n      // template syntax in quote string\n      tpl = this.getTplToken();\n      if (tpl) {\n        ret += tpl.value;\n        continue;\n      }\n      chr = this.text[this.pos];\n      code = chr.charCodeAt(0);\n      if (supportEscape && (code === 0x5c || escape)) {\n        escape = !escape;\n        ret += this.next();\n        continue;\n      }\n      // chr is quote, but next chr is not\n      if (!escape && code === quoteCode) {\n        if (!options.checkNext || this.text.charCodeAt(this.pos + 1) !== code) {\n          find = true;\n          ret += this.next();\n          break;\n        }\n      }\n      ret += this.next();\n    }\n    if (!find) {\n      if (options.throwError) {\n        this.error(Message.UnMatchedQuoteChar, true);\n      } else if (options.rollback) {\n        this.rollback();\n        return {\n          value: quote,\n          find: false\n        };\n      }\n    }\n    return {\n      value: ret,\n      find: find\n    };\n  }\n  /**\n   * get matched string\n   * not supoort tpl, nested, quote\n   * @param  {String} start []\n   * @param  {String} end   []\n   * @return {String}       []\n   */\n  getMatched(start, end) {\n    if (!this.lookAt(start)) {\n      return false;\n    }\n    let startLength = start.length, endLength = end.length;\n    const pos = this.find(end, startLength);\n    // can't find end string in text\n    if (pos === -1) {\n      return false;\n    }\n    return this.forward(pos - this.pos + endLength);\n  }\n  /**\n   * get match char, such as: [], (), {}\n   * @param  {Number} startCode [start char]\n   * @param  {Number} endCode   [end char]\n   * @return {String}           [matched char]\n   */\n  getMatchedChar(startCode, endCode, options = {}) {\n    if (this._text.charCodeAt(this.pos) !== startCode) {\n      return false;\n    }\n    let code, nextCode, comment, nums = 0;\n    let ret = this.next(), chr;\n    const quote = options.quote;\n    const multi_comment = options.multi_comment;\n    const line_comment = options.line_comment;\n    const nest = options.nest;\n    let supportEscape = options.escape, escape = false;\n\n    while (this.pos < this.length) {\n      chr = this.text[this.pos];\n      code = chr.charCodeAt(0);\n      if (supportEscape && (code === 0x5c || escape)) {\n        escape = !escape;\n        ret += this.next();\n        continue;\n      }\n      if (quote && !escape && (code === 0x22 || code === 0x27)) {\n        ret += this.getQuote({\n          rollback: true\n        }).value;\n        continue;\n      }\n      if (code === 0x2f) {\n        nextCode = this.text.charCodeAt(this.pos + 1);\n        comment = '';\n        if (multi_comment && nextCode === 0x2a) {\n          comment = this.getCommentToken(1, false);\n        } else if (line_comment && nextCode === 0x2f) {\n          comment = this.getCommentToken(0, false);\n        }\n        if (comment) {\n          ret += comment.value;\n          continue;\n        }\n      }\n      if (nest && code === startCode) {\n        nums++;\n      } else if (code === endCode) {\n        if (!nest || nums === 0) {\n          ret += this.next();\n          return ret;\n        }\n        nums--;\n      }\n      ret += this.next();\n    }\n    return ret;\n  }\n  /**\n   * start token\n   * @return {void} []\n   */\n  startToken() {\n    this._line = this.line;\n    this._col = this.col;\n    this._pos = this.pos;\n    // this._newlineBefore = this.newlineBefore;\n    // this._spaceBefore = this.spaceBefore;\n  }\n  /**\n   * get template token\n   * @return {Object} []\n   */\n  getTplToken() {\n    if (!this._hasTpl) {\n      return false;\n    }\n    let length = this.ld.length, ld, rd, tplInstance = this.getTplInstance();\n    let ret, value;\n    for (let i = 0; i < length; i++) {\n      ld = this.ld[i];\n      rd = this.rd[i];\n      ret = tplInstance.getMatched(ld, rd, this);\n      if (ret) {\n        if (ret.slice(0 - rd.length) === rd) {\n          value = ret.slice(ld.length, 0 - rd.length);\n        } else {\n          value = ret.slice(ld.length);\n        }\n        return this.getToken(TokenType.TPL, ret, {\n          ld: ld,\n          rd: rd,\n          value: value\n        });\n      }\n    }\n    return false;\n  }\n  /**\n   * check next chars is template syntax\n   * @return {Boolean} []\n   */\n  isTplNext() {\n    if (!this._hasTpl) {\n      return false;\n    }\n    const length = this.ld.length;\n    for (let i = 0; i < length; i++) {\n      if (this.lookAt(this.ld[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * get next token\n   * @return {Object} []\n   */\n  getNextToken() {\n    this.skipWhiteSpace();\n    this.skipComment();\n    this.startToken();\n    const token = this.getTplToken();\n    if (token !== false) {\n      return token;\n    }\n    if (this.pos >= this.length) {\n      return this.getLastToken();\n    }\n  }\n  /**\n   * get token info\n   * @param  {String} type  []\n   * @param  {String} value []\n   * @return {Object}       []\n   */\n  getToken(type, value, extra) {\n    const data = {\n      type: type,\n      value: value || '',\n      start: this._pos,\n      end: this.pos,\n      loc: {\n        start: {\n          line: this._line,\n          column: this._col\n        },\n        end: {\n          line: this.line,\n          column: this.col\n        }\n      },\n      // newlineBefore: this._newlineBefore,\n      // spaceBefore: this._spaceBefore,\n      commentBefore: this.commentBefore,\n      ext: {}\n    };\n    if (extra) {\n      for (const key in extra) {\n        data.ext[key] = extra[key];\n      }\n    }\n    // this.newlineBefore = this.spaceBefore = 0;\n    this.commentBefore = [];\n    return data;\n  }\n  /**\n   * get last token\n   * @return {Object} []\n   */\n  getLastToken() {\n    if (this.commentBefore.length) {\n      return this.getToken(TokenType.EOS);\n    }\n    return false;\n  }\n  /**\n   * get comment string\n   * @param  {String} type           []\n   * @return {Object}                []\n   */\n  getCommentToken(type, skipWhiteSpace/*, inText */) {\n    this.record();\n    let result;\n    if (type === 0) {\n      result = this.getLineComment();\n    } else {\n      const value = comments[type];\n      result = this.getMatched(value[0], value[1]);\n    }\n    if (!result) {\n      return false;\n    }\n    const data = {\n      value: result,\n      start: this._record.pos,\n      end: this.pos,\n      loc: {\n        start: {\n          line: this._record.line,\n          column: this._record.col\n        },\n        end: {\n          line: this.line,\n          column: this.col\n        }\n      }\n      // newlineBefore: this._record.newlineBefore,\n      // spaceBefore: this._record.spaceBefore\n    };\n    // if (inText) {\n    //   //data.newlineBefore = data.spaceBefore = 0;\n    // }\n    // this.newlineBefore = this.spaceBefore = 0;\n    if (skipWhiteSpace !== false) {\n      this.skipWhiteSpace();\n    }\n    return data;\n  }\n  /**\n   * get line comment\n   * @return {Object} []\n   */\n  getLineComment() {\n    if (!this.lookAt(lineComments[0])) {\n      return;\n    }\n    let ret = this.forward(lineComments[0].length);\n    let chr, code;\n    while (this.pos < this.length) {\n      chr = this.text[this.pos];\n      code = chr.charCodeAt(0);\n      if (code === 0x0a) {\n        break;\n      }\n      ret += this.next();\n    }\n    return ret;\n  }\n  /**\n   * run\n   * @return {Array} [text tokens]\n   */\n  run() {\n    let ret = [], token;\n    while (token = this.getNextToken()) {\n      ret.push(token);\n    }\n    return ret;\n  }\n}\n"]}