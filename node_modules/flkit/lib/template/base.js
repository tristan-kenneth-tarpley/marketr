'use strict';

exports.__esModule = true;

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BaseTemplate = function () {
  /**
   * constructor
   * @return {[type]} []
   */
  function BaseTemplate() {
    (0, _classCallCheck3.default)(this, BaseTemplate);
  }
  /**
   * has output
   * @return {Boolean} []
   */


  BaseTemplate.prototype.hasOutput = function hasOutput() {
    return false;
  };
  /**
   * check text has tpl
   * @param  {String} ld   []
   * @param  {String} rd   []
   * @param  {String} text []
   * @return {Boolean}      []
   */


  BaseTemplate.prototype.hasTpl = function hasTpl(text, ld, rd) {
    return text.indexOf(ld) > -1 && text.indexOf(rd) > -1;
  };

  /**
   * get tpl matched
   * @param  {Object} lexer []
   * @return {Object}       []
   */


  BaseTemplate.prototype._getMatched = function _getMatched(start, end, tokenizeInstance) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
      multiComment: false, // multi line comment
      lineComment: false, // line comment
      ignoreEnd: false, // ignore right delemiter
      nest: false, // allow nest delimiter
      quote: false // quote
    };

    if (!tokenizeInstance.lookAt(start)) {
      return false;
    }
    tokenizeInstance.record();
    var startLength = start.length,
        endLength = end.length;
    var pos = tokenizeInstance.find(end, startLength),
        ret = '';
    // can't find end string in text
    if (pos === -1) {
      // can ignore end chars, etc: php can ignore ?>
      if (options.ignoreEnd) {
        ret = tokenizeInstance.text.slice(tokenizeInstance.pos);
        tokenizeInstance.pos = tokenizeInstance.length;
        return ret;
      }
      return false;
    }
    ret = tokenizeInstance.forward(startLength);
    var nums = 0,
        chr = void 0,
        code = void 0,
        nextCode = void 0;
    var nest = options.nest,
        quote = options.quote,
        escape = false;
    var multiComment = options.multiComment;
    var lineComment = options.lineComment,
        comment = void 0;
    while (tokenizeInstance.pos < tokenizeInstance.length) {
      chr = tokenizeInstance.text[tokenizeInstance.pos];
      code = chr.charCodeAt(0);
      if (tokenizeInstance.lookAt(end)) {
        ret += tokenizeInstance.forward(endLength);
        if (!nest || nums === 0) {
          return ret;
        }
        nums--;
        continue;
      } else if (nest && tokenizeInstance.lookAt(start)) {
        ret += tokenizeInstance.forward(startLength);
        nums++;
        continue;
      }
      code = tokenizeInstance.text.charCodeAt(tokenizeInstance.pos);
      // quote char
      if (quote) {
        if (code === 0x5c || escape) {
          escape = !escape;
          ret += tokenizeInstance.next();
          continue;
        } else if (!escape && (code === 0x22 || code === 0x27)) {
          ret += tokenizeInstance.getQuote({
            rollback: true,
            escape: true
          }).value;
          continue;
        }
      }
      // comment
      if (code === 0x2f) {
        // /
        nextCode = tokenizeInstance.text.charCodeAt(tokenizeInstance.pos + 1);
        comment = '';
        if (multiComment && nextCode === 0x2a) {
          comment = tokenizeInstance.getCommentToken(1, false);
        } else if (lineComment && nextCode === 0x2f) {
          comment = tokenizeInstance.getCommentToken(0, false);
        }
        if (comment) {
          ret += comment.value;
          continue;
        }
      }
      ret += tokenizeInstance.next();
    }
    if (nums !== 0 && !options.ignoreEnd) {
      return tokenizeInstance.error('get matched string ' + start + ' & ' + end + ' error', true);
    }
    return ret;
  };
  /**
   * get template matched
   */


  BaseTemplate.prototype.getMatched = function getMatched(ld, rd, tokenizeInstance) {
    return this._getMatched(ld, rd, tokenizeInstance);
  };
  /**
   * compress tpl token
   */


  BaseTemplate.prototype.compress = function compress(token /*, tokenizeInstance */) {
    return token;
  };

  return BaseTemplate;
}();

exports.default = BaseTemplate;
//# sourceMappingURL=base.js.map