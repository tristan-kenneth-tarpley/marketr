{"version":3,"sources":["../../src/template/base.js"],"names":["BaseTemplate","hasOutput","hasTpl","text","ld","rd","indexOf","_getMatched","start","end","tokenizeInstance","options","multiComment","lineComment","ignoreEnd","nest","quote","lookAt","record","startLength","length","endLength","pos","find","ret","slice","forward","nums","chr","code","nextCode","escape","comment","charCodeAt","next","getQuote","rollback","value","getCommentToken","error","getMatched","compress","token"],"mappings":"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","file":"base.js","sourcesContent":["\nexport default class BaseTemplate {\n  /**\n   * constructor\n   * @return {[type]} []\n   */\n  constructor() {\n\n  }\n  /**\n   * has output\n   * @return {Boolean} []\n   */\n  hasOutput() {\n    return false;\n  }\n  /**\n   * check text has tpl\n   * @param  {String} ld   []\n   * @param  {String} rd   []\n   * @param  {String} text []\n   * @return {Boolean}      []\n   */\n  hasTpl(text, ld, rd) {\n    return text.indexOf(ld) > -1 && text.indexOf(rd) > -1;\n  }\n\n  /**\n   * get tpl matched\n   * @param  {Object} lexer []\n   * @return {Object}       []\n   */\n  _getMatched(start, end, tokenizeInstance, options = {\n    multiComment: false, // multi line comment\n    lineComment: false, // line comment\n    ignoreEnd: false, // ignore right delemiter\n    nest: false, // allow nest delimiter\n    quote: false // quote\n  }) {\n    if (!tokenizeInstance.lookAt(start)) {\n      return false;\n    }\n    tokenizeInstance.record();\n    let startLength = start.length, endLength = end.length;\n    let pos = tokenizeInstance.find(end, startLength), ret = '';\n    // can't find end string in text\n    if (pos === -1) {\n      // can ignore end chars, etc: php can ignore ?>\n      if (options.ignoreEnd) {\n        ret = tokenizeInstance.text.slice(tokenizeInstance.pos);\n        tokenizeInstance.pos = tokenizeInstance.length;\n        return ret;\n      }\n      return false;\n    }\n    ret = tokenizeInstance.forward(startLength);\n    let nums = 0, chr, code, nextCode;\n    let nest = options.nest, quote = options.quote, escape = false;\n    const multiComment = options.multiComment;\n    let lineComment = options.lineComment, comment;\n    while (tokenizeInstance.pos < tokenizeInstance.length) {\n      chr = tokenizeInstance.text[tokenizeInstance.pos];\n      code = chr.charCodeAt(0);\n      if (tokenizeInstance.lookAt(end)) {\n        ret += tokenizeInstance.forward(endLength);\n        if (!nest || nums === 0) {\n          return ret;\n        }\n        nums--;\n        continue;\n      } else if (nest && tokenizeInstance.lookAt(start)) {\n        ret += tokenizeInstance.forward(startLength);\n        nums++;\n        continue;\n      }\n      code = tokenizeInstance.text.charCodeAt(tokenizeInstance.pos);\n      // quote char\n      if (quote) {\n        if (code === 0x5c || escape) {\n          escape = !escape;\n          ret += tokenizeInstance.next();\n          continue;\n        } else if (!escape && (code === 0x22 || code === 0x27)) {\n          ret += tokenizeInstance.getQuote({\n            rollback: true,\n            escape: true\n          }).value;\n          continue;\n        }\n      }\n      // comment\n      if (code === 0x2f) { // /\n        nextCode = tokenizeInstance.text.charCodeAt(tokenizeInstance.pos + 1);\n        comment = '';\n        if (multiComment && nextCode === 0x2a) {\n          comment = tokenizeInstance.getCommentToken(1, false);\n        } else if (lineComment && nextCode === 0x2f) {\n          comment = tokenizeInstance.getCommentToken(0, false);\n        }\n        if (comment) {\n          ret += comment.value;\n          continue;\n        }\n      }\n      ret += tokenizeInstance.next();\n    }\n    if (nums !== 0 && !options.ignoreEnd) {\n      return tokenizeInstance.error(`get matched string ${start} & ${end} error`, true);\n    }\n    return ret;\n  }\n  /**\n   * get template matched\n   */\n  getMatched(ld, rd, tokenizeInstance) {\n    return this._getMatched(ld, rd, tokenizeInstance);\n  }\n  /**\n   * compress tpl token\n   */\n  compress(token/*, tokenizeInstance */) {\n    return token;\n  }\n}\n"]}